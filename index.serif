#|      _______    ___    _________    ___   ___    _______    ______
#|     /  ____/\  /  /\  /__   ___/\  /  /\ /  /\  /  ____/\  /  __  \
#|    /  /\___\/ /  / /  \_/  /\__\/ /  /_//  / / /  /\___\/ /  /\/  /\
#|   /  ____/\  /  / /    /  / /    /  ___   / / /  ____/\  /      _/ /
#|  /  /\___\/ /  / /    /  / /    /  /\_/  / / /  /\___\/ /  /|  |\\/
#| /______/\  /__/ /    /__/ /    /__/ //__/ / /______/\  /__/ |__| |
#| \______\/  \__\/     \__\/     \__\/ \__\/  \______\/  \__\/ \__\|
#|

# <a href="https://github.com/fantasyland/fantasy-land"><img alt="Fantasy Land" src="https://raw.githubusercontent.com/fantasyland/fantasy-land/master/logo.png" width="75" height="75" align="left"></a>
#
# # sanctuary-either
#
# The Either type represents values with two possibilities: a value of type
# `Either a b` is either a Left whose value is of type `a` or a Right whose
# value is of type `b`.

# import {"$equals" as equals} from "../serif/src/prelude.js";
import {} from "../serif/src/prelude.js";
# import {Either as EitherY, Left as LeftY, Right as RightY, either as eitherY} from "../serif/src/prelude.js";
import {default as show} from "sanctuary-show";
import {default as Z} from "sanctuary-type-classes";

export {EitherX, LeftX, RightX, eitherX};

let next = (x) => ({ tag: next, value: x });
let done = (x) => ({ tag: done, value: x });

#| `Either a b` satisfies the following [Fantasy Land][] specifications:
#|
#| ```javascript
#| > const Useless = require ("sanctuary-useless")
#|
#| > S.map (k => k + " ".repeat (16 - k.length) +
#| .             (Z[k].test (Right (Useless)) ? "\u2705   " :
#| .              Z[k].test (Right (["foo"])) ? "\u2705 * " :
#| .              /x* otherwise *x/               "\u274C   "))
#| .       (S.keys (S.unchecked.filter (S.is ($.TypeClass)) (Z)))
#| [ "Setoid          ✅ * ",  // if ‘a’ and ‘b’ satisfy Setoid
#| . "Ord             ✅ * ",  // if ‘a’ and ‘b’ satisfy Ord
#| . "Semigroupoid    ❌   ",
#| . "Category        ❌   ",
#| . "Semigroup       ✅ * ",  // if ‘a’ and ‘b’ satisfy Semigroup
#| . "Monoid          ❌   ",
#| . "Group           ❌   ",
#| . "Filterable      ❌   ",
#| . "Functor         ✅   ",
#| . "Bifunctor       ✅   ",
#| . "Profunctor      ❌   ",
#| . "Apply           ✅   ",
#| . "Applicative     ✅   ",
#| . "Chain           ✅   ",
#| . "ChainRec        ✅   ",
#| . "Monad           ✅   ",
#| . "Alt             ✅   ",
#| . "Plus            ❌   ",
#| . "Alternative     ❌   ",
#| . "Foldable        ✅   ",
#| . "Traversable     ✅   ",
#| . "Extend          ✅   ",
#| . "Comonad         ❌   ",
#| . "Contravariant   ❌   " ]
#| ```

#| # Either :: TypeRep Either
#| .
#| . Either [type representative][].

let EitherX = null ~ {
  "isLeft": false,
  "isRight": false,
  "fantasy-land/of": \(RightX %),
  "@@type": "sanctuary-either/Either@1",

  #| Either.either :: Either a b -> (a -> c) -> (b -> c) -> c
  "either": (this, a) => b => eitherX a b this,

  #| Either.fantasy-land/chainRec :: ((a -> c, b -> c, a) -> Either d c, a) -> Either d b
  #|
  #| ```javascript
  #| > Z.chainRec (
  #| .   Either,
  #| .   (next, done, x) =>
  #| .     x <= 1 ? Left ("!!") : Right (x >= 1000 ? done (x) : next (x * x)),
  #| .   1
  #| . )
  #| Left ("!!")
  #|
  #| > Z.chainRec (
  #| .   Either,
  #| .   (next, done, x) =>
  #| .     x <= 1 ? Left ("!!") : Right (x >= 1000 ? done (x) : next (x * x)),
  #| .   2
  #| . )
  #| Right (65536)
  #| ```
  "fantasy-land/chainRec": (f, x) => {
    let r = next (x);
    let res;
    while r.tag == next do {
      let either = f (next, done, r.value);
      if either.isLeft then {
        r.tag = done; # break loop
        res = either;
      } else {
        r = either.value;
      }
    }
    if typeof res != "undefined" then res else RightX r.value
  },
};
EitherX.constructor = EitherX;

let LeftPrototype = EitherX ~ {
  "isLeft": true,

  #| Either#@@show :: (Showable a, Showable b) => Either a b ~> () -> String
  #|
  #|   - `show (Left (x))` is equivalent to `"Left (" + show (x) + ")"`
  #|   - `show (Right (x))` is equivalent to `"Right (" + show (x) + ")"`
  #|
  #| ```javascript
  #| > S.show (Left ("sqrt undefined for -1"))
  #| "Left ("sqrt undefined for -1")"
  #|
  #| > S.show (Right ([1, 2, 3]))
  #| "Right ([1, 2, 3])"
  #| ```
  "@@show": (this) => "Left (\(show this.value))",

  #| Either.fantasy-land/of :: b -> Either a b
  #|
  #|   - `of (Either) (x)` is equivalent to `Right (x)`
  #|
  #| ```javascript
  #| > S.of (Either) (42)
  #| Right (42)
  #| ```
  "fantasy-land/of": (this, v) => {
    LeftX v
  },

  #| Either#fantasy-land/map :: Either a b ~> (b -> c) -> Either a c
  #|
  #|   - `map (f) (Left (x))` is equivalent to `Left (x)`
  #|   - `map (f) (Right (x))` is equivalent to `Right (f (x))`
  #|
  #| ```javascript
  #| > S.map (S.add (1)) (Left ("sqrt undefined for -1"))
  #| Left ("sqrt undefined for -1")
  #|
  #| > S.map (S.add (1)) (Right (99))
  #| Right (100)
  #| ```
  "fantasy-land/map": (this, f) => {
    this
  },

  #| Either#fantasy-land/bimap :: Either a c ~> (a -> b, c -> d) -> Either b d
  #|
  #|   - `bimap (f) (g) (Left (x))` is equivalent to `Left (f (x))`
  #|   - `bimap (f) (g) (Right (x))` is equivalent to `Right (g (x))`
  #|
  #| ```javascript
  #| > S.bimap (S.toUpper) (S.add (1)) (Left ("abc"))
  #| Left ("ABC")
  #|
  #| > S.bimap (S.toUpper) (S.add (1)) (Right (99))
  #| Right (100)
  #| ```
  "fantasy-land/bimap": (this, f, g) => {
    LeftX $ f this.value
  },

  #| Either#fantasy-land/chain :: Either a b ~> (b -> Either a c) -> Either a c
  #|
  #|   - `chain (f) (Left (x))` is equivalent to `Left (x)`
  #|   - `chain (f) (Right (x))` is equivalent to `f (x)`
  #|
  #| ```javascript
  #| > const sqrt = n => n < 0 ? Left ("sqrt undefined for " + S.show (n))
  #| .                         : Right (Math.sqrt (n))
  #|
  #| > S.chain (sqrt) (Left ("div undefined for 0"))
  #| Left ("div undefined for 0")
  #|
  #| > S.chain (sqrt) (Right (-1))
  #| Left ("sqrt undefined for -1")
  #|
  #| > S.chain (sqrt) (Right (25))
  #| Right (5)
  #| ```
  "fantasy-land/chain": (this, f) => {
    this
  },

  #| Either#fantasy-land/alt :: Either a b ~> Either a b -> Either a b
  #|
  #|   - `alt (Left (y)) (Left (x))` is equivalent to `Left (y)`
  #|   - `alt (Right (y)) (Left (x))` is equivalent to `Right (y)`
  #|   - `alt (Left (y)) (Right (x))` is equivalent to `Right (x)`
  #|   - `alt (Right (y)) (Right (x))` is equivalent to `Right (x)`
  #|
  #| ```javascript
  #| > S.alt (Left ("B")) (Left ("A"))
  #| Left ("B")
  #|
  #| > S.alt (Right (1)) (Left ("C"))
  #| Right (1)
  #|
  #| > S.alt (Left ("D")) (Right (2))
  #| Right (2)
  #|
  #| > S.alt (Right (4)) (Right (3))
  #| Right (3)
  #| ```
  "fantasy-land/alt": (this, that) => {
    that
  },

  #| Either#fantasy-land/reduce :: Either a b ~> ((c, b) -> c, c) -> c
  #|
  #|   - `reduce (f) (x) (Left (y))` is equivalent to `x`
  #|   - `reduce (f) (x) (Right (y))` is equivalent to `f (x) (y)`
  #|
  #| ```javascript
  #| > S.reduce (S.concat) ([1]) (Left ("sqrt undefined for -1"))
  #| [1]
  #|
  #| > S.reduce (S.concat) ([1]) (Right ([2]))
  #| [1, 2]
  #| ```
  "fantasy-land/reduce": (this, f, x) => {
    x
  },

  #| Either#fantasy-land/traverse :: Applicative f => Either a b ~> (TypeRep f, b -> f c) -> f (Either a c)
  #|
  #|   - `traverse (A) (f) (Left (x))` is equivalent to `of (A) (Left (x))`
  #|   - `traverse (A) (f) (Right (x))` is equivalent to `map (Right) (f (x))`
  #|
  #| ```javascript
  #| > S.traverse (Array) (S.words) (Left ("sqrt undefined for -1"))
  #| [Left ("sqrt undefined for -1")]
  #|
  #| > S.traverse (Array) (S.words) (Right ("foo bar baz"))
  #| [Right ("foo"), Right ("bar"), Right ("baz")]
  #| ```
  "fantasy-land/traverse": (this, typeRep, f) => {
    of typeRep this
  },

  #| Either#fantasy-land/extend :: Either a b ~> (Either a b -> c) -> Either a c
  #|
  #|   - `extend (f) (Left (x))` is equivalent to `Left (x)`
  #|   - `extend (f) (Right (x))` is equivalent to `Right (f (Right (x)))`
  #|
  #| ```javascript
  #| > S.extend (S.reduce (S.add) (1)) (Left ("sqrt undefined for -1"))
  #| Left ("sqrt undefined for -1")
  #|
  #| > S.extend (S.reduce (S.add) (1)) (Right (99))
  #| Right (100)
  #| ```
  "fantasy-land/extend": (this, f) => {
    this
  },

  #| Either#fantasy-land/ap :: Either a b ~> Either a (b -> c) -> Either a c
  #|
  #|   - `ap (Left (x)) (Left (y))` is equivalent to `Left (x)`
  #|   - `ap (Left (x)) (Right (y))` is equivalent to `Left (x)`
  #|   - `ap (Right (f)) (Left (x))` is equivalent to `Left (x)`
  #|   - `ap (Right (f)) (Right (x))` is equivalent to `Right (f (x))`
  #|
  #| ```javascript
  #| > S.ap (Left ("div undefined for 0")) (Left ("sqrt undefined for -1"))
  #| Left ("div undefined for 0")
  #|
  #| > S.ap (Left ("div undefined for 0")) (Right (99))
  #| Left ("div undefined for 0")
  #|
  #| > S.ap (Right (S.add (1))) (Left ("sqrt undefined for -1"))
  #| Left ("sqrt undefined for -1")
  #|
  #| > S.ap (Right (S.add (1))) (Right (99))
  #| Right (100)
  #| ```
  "fantasy-land/ap": (this, that) => {
    if that.isLeft then that else this
  },
};

let RightPrototype = EitherX ~ {
  "isRight": true,

  #| Either#@@show :: (Showable a, Showable b) => Either a b ~> () -> String
  #|
  #|   - `show (Left (x))` is equivalent to `"Left (" + show (x) + ")"`
  #|   - `show (Right (x))` is equivalent to `"Right (" + show (x) + ")"`
  #|
  #| ```javascript
  #| > S.show (Left ("sqrt undefined for -1"))
  #| "Left ("sqrt undefined for -1")"
  #|
  #| > S.show (Right ([1, 2, 3]))
  #| "Right ([1, 2, 3])"
  #| ```
  "@@show": (this) => "Right (\(show this.value))",

  # "fantasy-land/equals": (this, that) => {
  #   that.isRight && equals (this.value, that.value)
  # },
  "fantasy-land/of": (this, v) => {
    RightX v
  },

  #| Either#fantasy-land/map :: Either a b ~> (b -> c) -> Either a c
  #|
  #|   - `map (f) (Left (x))` is equivalent to `Left (x)`
  #|   - `map (f) (Right (x))` is equivalent to `Right (f (x))`
  #|
  #| ```javascript
  #| > S.map (S.add (1)) (Left ("sqrt undefined for -1"))
  #| Left ("sqrt undefined for -1")
  #|
  #| > S.map (S.add (1)) (Right (99))
  #| Right (100)
  #| ```
  "fantasy-land/map": (this, f) => {
    RightX $ f this.value
  },

  #| Either#fantasy-land/bimap :: Either a c ~> (a -> b, c -> d) -> Either b d
  #|
  #|   - `bimap (f) (g) (Left (x))` is equivalent to `Left (f (x))`
  #|   - `bimap (f) (g) (Right (x))` is equivalent to `Right (g (x))`
  #|
  #| ```javascript
  #| > S.bimap (S.toUpper) (S.add (1)) (Left ("abc"))
  #| Left ("ABC")
  #|
  #| > S.bimap (S.toUpper) (S.add (1)) (Right (99))
  #| Right (100)
  #| ```
  "fantasy-land/bimap": (this, f, g) => {
    RightX $ g this.value
  },

  #| Either#fantasy-land/chain :: Either a b ~> (b -> Either a c) -> Either a c
  #|
  #|   - `chain (f) (Left (x))` is equivalent to `Left (x)`
  #|   - `chain (f) (Right (x))` is equivalent to `f (x)`
  #|
  #| ```javascript
  #| > const sqrt = n => n < 0 ? Left ("sqrt undefined for " + S.show (n))
  #| .                         : Right (Math.sqrt (n))
  #|
  #| > S.chain (sqrt) (Left ("div undefined for 0"))
  #| Left ("div undefined for 0")
  #|
  #| > S.chain (sqrt) (Right (-1))
  #| Left ("sqrt undefined for -1")
  #|
  #| > S.chain (sqrt) (Right (25))
  #| Right (5)
  #| ```
  "fantasy-land/chain": (this, f) => {
    f this.value
  },

  #| Either#fantasy-land/alt :: Either a b ~> Either a b -> Either a b
  #|
  #|   - `alt (Left (y)) (Left (x))` is equivalent to `Left (y)`
  #|   - `alt (Right (y)) (Left (x))` is equivalent to `Right (y)`
  #|   - `alt (Left (y)) (Right (x))` is equivalent to `Right (x)`
  #|   - `alt (Right (y)) (Right (x))` is equivalent to `Right (x)`
  #|
  #| ```javascript
  #| > S.alt (Left ("B")) (Left ("A"))
  #| Left ("B")
  #|
  #| > S.alt (Right (1)) (Left ("C"))
  #| Right (1)
  #|
  #| > S.alt (Left ("D")) (Right (2))
  #| Right (2)
  #|
  #| > S.alt (Right (4)) (Right (3))
  #| Right (3)
  #| ```
  "fantasy-land/alt": (this, that) => {
    this
  },

  #| Either#fantasy-land/reduce :: Either a b ~> ((c, b) -> c, c) -> c
  #|
  #|   - `reduce (f) (x) (Left (y))` is equivalent to `x`
  #|   - `reduce (f) (x) (Right (y))` is equivalent to `f (x) (y)`
  #|
  #| ```javascript
  #| > S.reduce (S.concat) ([1]) (Left ("sqrt undefined for -1"))
  #| [1]
  #|
  #| > S.reduce (S.concat) ([1]) (Right ([2]))
  #| [1, 2]
  #| ```
  "fantasy-land/reduce": (this, f, x) => {
    # console.log ("Right reduce f x", f, x, this.value);
    f (x, this.value)
  },

  #| Either#fantasy-land/traverse :: Applicative f => Either a b ~> (TypeRep f, b -> f c) -> f (Either a c)
  #|
  #|   - `traverse (A) (f) (Left (x))` is equivalent to `of (A) (Left (x))`
  #|   - `traverse (A) (f) (Right (x))` is equivalent to `map (Right) (f (x))`
  #|
  #| ```javascript
  #| > S.traverse (Array) (S.words) (Left ("sqrt undefined for -1"))
  #| [Left ("sqrt undefined for -1")]
  #|
  #| > S.traverse (Array) (S.words) (Right ("foo bar baz"))
  #| [Right ("foo"), Right ("bar"), Right ("baz")]
  #| ```
  "fantasy-land/traverse": (this, typeRep, f) => {
    map RightX $ f this.value
  },

  #| Either#fantasy-land/extend :: Either a b ~> (Either a b -> c) -> Either a c
  #|
  #|   - `extend (f) (Left (x))` is equivalent to `Left (x)`
  #|   - `extend (f) (Right (x))` is equivalent to `Right (f (Right (x)))`
  #|
  #| ```javascript
  #| > S.extend (S.reduce (S.add) (1)) (Left ("sqrt undefined for -1"))
  #| Left ("sqrt undefined for -1")
  #|
  #| > S.extend (S.reduce (S.add) (1)) (Right (99))
  #| Right (100)
  #| ```
  "fantasy-land/extend": (this, f) => {
    RightX $ f this
  },

  #| Either#fantasy-land/ap :: Either a b ~> Either a (b -> c) -> Either a c
  #|
  #|   - `ap (Left (x)) (Left (y))` is equivalent to `Left (x)`
  #|   - `ap (Left (x)) (Right (y))` is equivalent to `Left (x)`
  #|   - `ap (Right (f)) (Left (x))` is equivalent to `Left (x)`
  #|   - `ap (Right (f)) (Right (x))` is equivalent to `Right (f (x))`
  #|
  #| ```javascript
  #| > S.ap (Left ("div undefined for 0")) (Left ("sqrt undefined for -1"))
  #| Left ("div undefined for 0")
  #|
  #| > S.ap (Left ("div undefined for 0")) (Right (99))
  #| Left ("div undefined for 0")
  #|
  #| > S.ap (Right (S.add (1))) (Left ("sqrt undefined for -1"))
  #| Left ("sqrt undefined for -1")
  #|
  #| > S.ap (Right (S.add (1))) (Right (99))
  #| Right (100)
  #| ```
  "fantasy-land/ap": (this, that) => {
    if that.isLeft then that else RightX $ that.value this.value
  },
};

#| Either#fantasy-land/equals :: (Setoid a, Setoid b) => Either a b ~> Either a b -> Boolean
#|
#|   - `Left (x)` is equal to `Left (y)` [iff][] `x` is equal to `y`
#|     according to [`Z.equals`][]
#|   - `Right (x)` is equal to `Right (y)` [iff][] `x` is equal to `y`
#|     according to [`Z.equals`][]
#|   - `Left (x)` is never equal to `Right (y)`
#|
#| ```javascript
#| > S.equals (Left ([1, 2, 3])) (Left ([1, 2, 3]))
#| true
#|
#| > S.equals (Right ([1, 2, 3])) (Right ([1, 2, 3]))
#| true
#|
#| > S.equals (Left ([1, 2, 3])) (Right ([1, 2, 3]))
#| false
#| ```
let LeftXprototypeXequals = (this, that) => {
  that.isLeft && Z.equals (this.value, that.value)
};
let RightXprototypeXequals = (this, that) => {
  that.isRight && Z.equals (this.value, that.value)
};

#| Either#fantasy-land/lte :: (Ord a, Ord b) => Either a b ~> Either a b -> Boolean
#|
#|   - `Left (x)` is less than or equal to `Left (y)` [iff][] `x` is less
#|     than or equal to `y` according to [`Z.lte`][]
#|   - `Right (x)` is less than or equal to `Right (y)` [iff][] `x` is less
#|     than or equal to `y` according to [`Z.lte`][]
#|   - `Left (x)` is always less than `Right (y)`
#|
#| ```javascript
#| > S.filter (S.lte (Left (1))) ([Left (0), Left (1), Left (2)])
#| [Left (0), Left (1)]
#|
#| > S.filter (S.lte (Right (1))) ([Right (0), Right (1), Right (2)])
#| [Right (0), Right (1)]
#|
#| > S.filter (S.lte (Left (1))) ([Right (0), Right (1), Right (2)])
#| []
#|
#| > S.filter (S.lte (Right (1))) ([Left (0), Left (1), Left (2)])
#| [Left (0), Left (1), Left (2)]
#| ```
let LeftXprototypeXlte = (this, that) => {
  that.isRight || Z.lte (this.value, that.value)
};

let RightXprototypeXlte = (this, that) => {
  that.isRight && Z.lte (this.value, that.value)
};

#| Either#fantasy-land/concat :: (Semigroup a, Semigroup b) => Either a b ~> Either a b -> Either a b
#|
#|   - `concat (Left (x)) (Left (y))` is equivalent to
#|     `Left (concat (x) (y))`
#|   - `concat (Right (x)) (Right (y))` is equivalent to
#|     `Right (concat (x) (y))`
#|   - `concat (Left (x)) (Right (y))` is equivalent to `Right (y)`
#|   - `concat (Right (x)) (Left (y))` is equivalent to `Right (x)`
#|
#| ```javascript
#| > S.concat (Right ([1, 2, 3])) (Right ([4, 5, 6]))
#| Right ([1, 2, 3, 4, 5, 6])
#|
#| > S.concat (Left ("abc")) (Right ([1, 2, 3]))
#| Right ([1, 2, 3])
#|
#| > S.concat (Right ([1, 2, 3])) (Left ("abc"))
#| Right ([1, 2, 3])
#| ```
let LeftXprototypeXconcat = (this, that) => {
  if that.isLeft then LeftX $ Z.concat (this.value, that.value) else that
};
let RightXprototypeXconcat = (this, that) => {
  if that.isRight then RightX $ Z.concat (this.value, that.value) else this
};

#| Left :: a -> Either a b
#|
#| Constructs a value of type `Either a b` from a value of type `a`.
#|
#| ```javascript
#| > Left ("sqrt undefined for -1")
#| Left ("sqrt undefined for -1")
#| ```
let LeftX = a => {
  let left = LeftPrototype ~ {value: a};
  if Z.Setoid.test a then {
    left["fantasy-land/equals"] = LeftXprototypeXequals;
    if Z.Ord.test a then left["fantasy-land/lte"] = LeftXprototypeXlte;
  }
  if Z.Semigroup.test a then left["fantasy-land/concat"] = LeftXprototypeXconcat;
  left
};

#| Right :: b -> Either a b
#|
#| Constructs a value of type `Either a b` from a value of type `b`.
#|
#| ```javascript
#| > Right (42)
#| Right (42)
#| ```
let RightX = b => {
  let right = RightPrototype ~ {value: b};
  if Z.Setoid.test b then {
    right["fantasy-land/equals"] = RightXprototypeXequals;
    if Z.Ord.test b then right["fantasy-land/lte"] = RightXprototypeXlte;
  }
  if Z.Semigroup.test b then right["fantasy-land/concat"] = RightXprototypeXconcat;
  right
};

#| either :: (a -> c) -> (b -> c) -> Either a b -> c
#|
#| Case-folding function.
#|
#|   - `either (f) (g) (Left (x))` is equivalent to `f (x)`
#|   - `either (f) (g) (Right (x))` is equivalent to `g (x)`
#|
#| ```javascript
#| > Either.either (a => "left:" + a) (b => "right:" + b) (Left ("foo"))
#| "left:foo"
#|
#| > Either.either (a => "left:" + a) (b => "right:" + b) (Right ("bar"))
#| "right:bar"
#| ```
let eitherX = \if %3.isLeft then %1 %3.value else %2 %3.value;
